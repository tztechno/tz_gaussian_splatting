<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Splatting WebGL Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        header {
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        .controls {
            display: flex;
            gap: 0.5rem;
        }
        button, .file-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .btn-primary {
            background: #2563eb;
            color: white;
        }
        .btn-primary:hover {
            background: #1d4ed8;
        }
        .btn-secondary {
            background: #059669;
            color: white;
        }
        .btn-secondary:hover {
            background: #047857;
        }
        .btn-gray {
            background: #4b5563;
            color: white;
        }
        .btn-gray:hover {
            background: #374151;
        }
        .file-btn {
            position: relative;
            overflow: hidden;
        }
        .file-btn input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }
        #canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            backdrop-filter: blur(10px);
            max-width: 250px;
        }
        .info-panel h3 {
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }
        .info-panel p {
            margin: 0.25rem 0;
            color: #aaa;
        }
        .playback-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 1rem;
            backdrop-filter: blur(10px);
            min-width: 400px;
        }
        .playback-controls button {
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .playback-controls input[type="range"] {
            flex: 1;
            height: 4px;
            background: #4b5563;
            border-radius: 2px;
            outline: none;
        }
        .mode-toggle {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
        }
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #2563eb;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <header>
            <h1>üé® Gaussian Splatting WebGL Viewer</h1>
            <div class="controls">
                <label class="file-btn btn-primary">
                    üìÅ PLY„Éï„Ç°„Ç§„É´
                    <input type="file" id="plyInput" accept=".ply">
                </label>
                <label class="file-btn btn-secondary">
                    üé• „Ç´„É°„É©„Éë„Çπ
                    <input type="file" id="cameraInput" accept=".json">
                </label>
                <button class="btn-gray" id="resetBtn">üîÑ „É™„Çª„ÉÉ„Éà</button>
            </div>
        </header>
        
        <div id="canvas-container">
            <canvas id="glCanvas"></canvas>
            
            <div class="info-panel">
                <h3 id="modeTitle">„Éû„Éã„É•„Ç¢„É´„É¢„Éº„Éâ</h3>
                <p>üñ±Ô∏è „Éâ„É©„ÉÉ„Ç∞: ÂõûËª¢</p>
                <p>üîÑ „Éõ„Ç§„Éº„É´: „Ç∫„Éº„É†</p>
                <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #333;">
                    <p>„Ç¨„Ç¶„Ç∑„Ç¢„É≥Êï∞: <span id="pointCount">0</span></p>
                    <p>FPS: <span id="fps">0</span></p>
                    <p id="cameraInfo" class="hidden">„Ç´„É°„É©: <span id="cameraCount">0</span></p>
                </div>
            </div>
            
            <div class="mode-toggle hidden" id="modeToggle">
                <button class="btn-gray" id="toggleModeBtn">üé• „Ç´„É°„É©„Éë„Çπ„É¢„Éº„Éâ</button>
            </div>
            
            <div class="playback-controls hidden" id="playbackControls">
                <button class="btn-primary" id="playBtn">‚ñ∂Ô∏è</button>
                <input type="range" id="frameSlider" min="0" max="100" value="0">
                <span id="frameInfo">0 / 0</span>
            </div>
            
            <div class="loading hidden" id="loading">
                <div class="spinner"></div>
                <p>Ë™≠„ÅøËæº„Åø‰∏≠...</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2', { 
            antialias: true,
            alpha: false,
            depth: true,
            premultipliedAlpha: false
        });

        if (!gl) {
            alert('WebGL2„Åå„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
        }

        let gaussians = [];
        let cameras = [];
        let currentCameraIndex = 0;
        let isPlaying = false;
        let useManualControl = true;
        let lastFrameTime = 0;
        let fps = 0;

        let rotation = { x: 0, y: 0 };
        let zoom = 5;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };

        let shaderProgram;
        let vertexBuffer;
        let colorBuffer;
        let sizeBuffer;

        const vertexShaderSource = '#version 300 es\n' +
            'precision highp float;\n' +
            'in vec3 aPosition;\n' +
            'in vec3 aColor;\n' +
            'in float aSize;\n' +
            'uniform mat4 uProjectionMatrix;\n' +
            'uniform mat4 uViewMatrix;\n' +
            'uniform float uZoom;\n' +
            'out vec3 vColor;\n' +
            'out float vSize;\n' +
            'void main() {\n' +
            '    vec4 viewPos = uViewMatrix * vec4(aPosition, 1.0);\n' +
            '    gl_Position = uProjectionMatrix * viewPos;\n' +
            '    float perspectiveSize = aSize * uZoom / (1.0 + max(0.0, -viewPos.z) * 0.1);\n' +
            '    gl_PointSize = max(1.0, perspectiveSize);\n' +
            '    vColor = aColor;\n' +
            '    vSize = perspectiveSize;\n' +
            '}\n';

        const fragmentShaderSource = '#version 300 es\n' +
            'precision highp float;\n' +
            'in vec3 vColor;\n' +
            'in float vSize;\n' +
            'out vec4 fragColor;\n' +
            'void main() {\n' +
            '    vec2 coord = gl_PointCoord - vec2(0.5);\n' +
            '    float dist = length(coord);\n' +
            '    float alpha = exp(-dist * dist * 4.0);\n' +
            '    if (alpha < 0.01) discard;\n' +
            '    vec3 brightColor = vColor * 1.5;\n' +
            '    fragColor = vec4(brightColor, alpha * 0.8);\n' +
            '}\n';

        function initWebGL() {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
            
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Shader program failed to link:', gl.getProgramInfoLog(shaderProgram));
                return;
            }
            
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
            gl.enable(gl.DEPTH_TEST);
            gl.depthMask(false);
            
            vertexBuffer = gl.createBuffer();
            colorBuffer = gl.createBuffer();
            sizeBuffer = gl.createBuffer();
        }

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        async function parsePLY(text) {
            showLoading(true);
            
            const lines = text.split('\n');
            let vertexCount = 0;
            let headerEnd = 0;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.includes('element vertex')) {
                    vertexCount = parseInt(line.split(/\s+/)[2]);
                }
                if (line === 'end_header') {
                    headerEnd = i + 1;
                    break;
                }
            }
            
            console.log('Parsing ' + vertexCount + ' gaussians...');
            
            gaussians = [];
            
            for (let i = headerEnd; i < lines.length && gaussians.length < vertexCount; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split(/\s+/);
                if (parts.length >= 3) {
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    const z = parseFloat(parts[2]);
                    
                    let r = 128;
                    let g = 128;
                    let b = 128;
                    if (parts.length >= 6) {
                        r = parseInt(parts[3]);
                        g = parseInt(parts[4]);
                        b = parseInt(parts[5]);
                    }
                    
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        gaussians.push({
                            position: [x, y, z],
                            color: [r / 255, g / 255, b / 255],
                            size: 8.0
                        });
                    }
                }
            }
            
            if (gaussians.length > 0) {
                const positions = gaussians.map(function(g) { return g.position; });
                const xs = positions.map(function(p) { return p[0]; });
                const ys = positions.map(function(p) { return p[1]; });
                const zs = positions.map(function(p) { return p[2]; });
                
                const minX = Math.min.apply(null, xs);
                const maxX = Math.max.apply(null, xs);
                const minY = Math.min.apply(null, ys);
                const maxY = Math.max.apply(null, ys);
                const minZ = Math.min.apply(null, zs);
                const maxZ = Math.max.apply(null, zs);
                
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                const scale = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
                
                gaussians.forEach(function(g) {
                    g.position[0] = (g.position[0] - centerX) / scale * 2;
                    g.position[1] = (g.position[1] - centerY) / scale * 2;
                    g.position[2] = (g.position[2] - centerZ) / scale * 2;
                });
            }
            
            updateBuffers();
            document.getElementById('pointCount').textContent = gaussians.length.toLocaleString();
            
            showLoading(false);
            console.log('Loaded ' + gaussians.length + ' gaussians');
        }

        function updateBuffers() {
            if (gaussians.length === 0) return;
            
            const positions = new Float32Array(gaussians.length * 3);
            const colors = new Float32Array(gaussians.length * 3);
            const sizes = new Float32Array(gaussians.length);
            
            for (let i = 0; i < gaussians.length; i++) {
                positions[i * 3] = gaussians[i].position[0];
                positions[i * 3 + 1] = gaussians[i].position[1];
                positions[i * 3 + 2] = gaussians[i].position[2];
                
                colors[i * 3] = gaussians[i].color[0];
                colors[i * 3 + 1] = gaussians[i].color[1];
                colors[i * 3 + 2] = gaussians[i].color[2];
                
                sizes[i] = gaussians[i].size;
            }
            
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.STATIC_DRAW);
        }

        function createProjectionMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return [
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ];
        }

        function createViewMatrix() {
            const cam = getCamera();
            
            if (cam.rotationMatrix) {
                const R = cam.rotationMatrix;
                const pos = cam.position;
                
                return [
                    R[0][0], R[1][0], R[2][0], 0,
                    R[0][1], R[1][1], R[2][1], 0,
                    R[0][2], R[1][2], R[2][2], 0,
                    -(R[0][0] * pos[0] + R[1][0] * pos[1] + R[2][0] * pos[2]),
                    -(R[0][1] * pos[0] + R[1][1] * pos[1] + R[2][1] * pos[2]),
                    -(R[0][2] * pos[0] + R[1][2] * pos[1] + R[2][2] * pos[2]),
                    1
                ];
            } else {
                const mat = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                
                mat[12] = -cam.position[0];
                mat[13] = -cam.position[1];
                mat[14] = -cam.position[2];
                
                const cosX = Math.cos(cam.rotation[0]);
                const sinX = Math.sin(cam.rotation[0]);
                const cosY = Math.cos(cam.rotation[1]);
                const sinY = Math.sin(cam.rotation[1]);
                
                const rotX = [
                    1, 0, 0, 0,
                    0, cosX, sinX, 0,
                    0, -sinX, cosX, 0,
                    0, 0, 0, 1
                ];
                
                const rotY = [
                    cosY, 0, -sinY, 0,
                    0, 1, 0, 0,
                    sinY, 0, cosY, 0,
                    0, 0, 0, 1
                ];
                
                return multiplyMatrices(rotX, multiplyMatrices(rotY, mat));
            }
        }

        function multiplyMatrices(a, b) {
            const result = new Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return result;
        }

        function getCamera() {
            if (!useManualControl && cameras.length > 0) {
                const cam = cameras[currentCameraIndex];
                return {
                    position: cam.position,
                    rotationMatrix: cam.rotationMatrix,
                    rotation: null
                };
            }
            return {
                position: [0, 0, zoom],
                rotation: [rotation.x, rotation.y],
                rotationMatrix: null
            };
        }

        function render(time) {
            if (lastFrameTime > 0) {
                fps = Math.round(1000 / (time - lastFrameTime));
                document.getElementById('fps').textContent = fps;
            }
            lastFrameTime = time;
            
            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            gl.clearColor(0.04, 0.04, 0.04, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            if (gaussians.length === 0) {
                requestAnimationFrame(render);
                return;
            }
            
            gl.useProgram(shaderProgram);
            
            const aspect = canvas.width / canvas.height;
            const projectionMatrix = createProjectionMatrix(Math.PI / 4, aspect, 0.1, 100);
            const viewMatrix = createViewMatrix();
            
            const uProjection = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
            const uView = gl.getUniformLocation(shaderProgram, 'uViewMatrix');
            const uZoom = gl.getUniformLocation(shaderProgram, 'uZoom');
            
            gl.uniformMatrix4fv(uProjection, false, projectionMatrix);
            gl.uniformMatrix4fv(uView, false, viewMatrix);
            gl.uniform1f(uZoom, zoom * 50);
            
            const aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
            
            const aColor = gl.getAttribLocation(shaderProgram, 'aColor');
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.enableVertexAttribArray(aColor);
            gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
            
            const aSize = gl.getAttribLocation(shaderProgram, 'aSize');
            gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
            gl.enableVertexAttribArray(aSize);
            gl.vertexAttribPointer(aSize, 1, gl.FLOAT, false, 0, 0);
            
            gl.drawArrays(gl.POINTS, 0, gaussians.length);
            
            requestAnimationFrame(render);
        }

        canvas.addEventListener('mousedown', function(e) {
            if (!useManualControl) return;
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', function(e) {
            if (!isDragging || !useManualControl) return;
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            rotation.y += dx * 0.01;
            rotation.x += dy * 0.01;
            lastMouse = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseup', function() {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', function() {
            isDragging = false;
        });

        canvas.addEventListener('wheel', function(e) {
            if (!useManualControl) return;
            e.preventDefault();
            zoom = Math.max(1, Math.min(15, zoom - e.deltaY * 0.01));
        });

        document.getElementById('plyInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                parsePLY(ev.target.result);
            };
            reader.readAsText(file);
        });

        document.getElementById('cameraInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(ev) {
                try {
                    const data = JSON.parse(ev.target.result);
                    console.log('Loaded camera JSON:', data);
                    
                    let cameraArray = null;
                    if (Array.isArray(data)) {
                        cameraArray = data;
                    } else if (data.cameras && Array.isArray(data.cameras)) {
                        cameraArray = data.cameras;
                    } else if (data.camera_list && Array.isArray(data.camera_list)) {
                        cameraArray = data.camera_list;
                    }
                    
                    if (!cameraArray || cameraArray.length === 0) {
                        alert('„Ç´„É°„É©„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                        return;
                    }
                    
                    console.log('Found ' + cameraArray.length + ' cameras');
                    
                    cameras = cameraArray.map(function(cam) {
                        let position = cam.position || cam.camera_center || [0, 0, 5];
                        let rotationMatrix = null;
                        
                        if (cam.rotation && Array.isArray(cam.rotation) && Array.isArray(cam.rotation[0])) {
                            rotationMatrix = cam.rotation;
                        }
                        
                        return {
                            position: Array.isArray(position) ? position : [0, 0, 5],
                            rotationMatrix: rotationMatrix,
                            fx: cam.fx || 1500,
                            fy: cam.fy || 1500
                        };
                    });
                    
                    document.getElementById('cameraCount').textContent = cameras.length;
                    document.getElementById('cameraInfo').classList.remove('hidden');
                    document.getElementById('modeToggle').classList.remove('hidden');
                    document.getElementById('playbackControls').classList.remove('hidden');
                    document.getElementById('frameSlider').max = cameras.length - 1;
                    
                    useManualControl = false;
                    document.getElementById('modeTitle').textContent = '„Ç´„É°„É©„Éë„Çπ„É¢„Éº„Éâ';
                    document.getElementById('toggleModeBtn').textContent = 'üñ±Ô∏è „Éû„Éã„É•„Ç¢„É´„É¢„Éº„Éâ';
                    
                    updatePlaybackUI();
                    alert('‚úÖ ' + cameras.length + 'ÂÄã„ÅÆ„Ç´„É°„É©„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºÅ');
                    
                } catch (err) {
                    alert('„Ç´„É°„É©JSON„ÅÆË™≠„ÅøËæº„Åø„Ç®„É©„Éº:\n' + err.message);
                    console.error('Camera JSON parse error:', err);
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('resetBtn').addEventListener('click', function() {
            rotation = { x: 0, y: 0 };
            zoom = 5;
            currentCameraIndex = 0;
            isPlaying = false;
            updatePlaybackUI();
        });

        document.getElementById('toggleModeBtn').addEventListener('click', function() {
            useManualControl = !useManualControl;
            document.getElementById('modeTitle').textContent = useManualControl ? '„Éû„Éã„É•„Ç¢„É´„É¢„Éº„Éâ' : '„Ç´„É°„É©„Éë„Çπ„É¢„Éº„Éâ';
            document.getElementById('toggleModeBtn').textContent = useManualControl ? 'üé• „Ç´„É°„É©„Éë„Çπ„É¢„Éº„Éâ' : 'üñ±Ô∏è „Éû„Éã„É•„Ç¢„É´„É¢„Éº„Éâ';
            document.getElementById('playbackControls').classList.toggle('hidden', useManualControl);
        });

        document.getElementById('playBtn').addEventListener('click', function() {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
        });

        document.getElementById('frameSlider').addEventListener('input', function(e) {
            currentCameraIndex = parseInt(e.target.value);
            isPlaying = false;
            updatePlaybackUI();
        });

        function updatePlaybackUI() {
            document.getElementById('frameSlider').value = currentCameraIndex;
            document.getElementById('frameInfo').textContent = (currentCameraIndex + 1) + ' / ' + cameras.length;
            document.getElementById('playBtn').textContent = isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
        }

        setInterval(function() {
            if (isPlaying && cameras.length > 0) {
                currentCameraIndex = (currentCameraIndex + 1) % cameras.length;
                updatePlaybackUI();
            }
        }, 1000 / 30);

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
        }

        initWebGL();
        requestAnimationFrame(render);
    </script>
</body>
</html>
